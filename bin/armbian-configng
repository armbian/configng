#!/bin/bash

# This script provides a command-line interface for managing Armbian configuration.
# It loads libraries of functions from the lib directory and displays them in a menu.
# The user can select a function to run, or use a text-based user interface (TUI) to navigate the menus.
# The script also provides a help option and a debug option for developers.
# The script requires sudo privileges to run some functions.
# The script uses whiptail or dialog for the TUI, depending on which is available.

# TODO: Add more detailed documentation for each function and option in the script.

clear
# Sudo Users Home

if [ "$(id -u)" = "0" ]; then
    # This block is executed if the script is run with sudo
    # echo "Running with root privileges."
    USER_HOME=$(eval echo ~"$SUDO_USER")
else
    # This block is executed if the script is not run with sudo
    printf '%s\n' "Running without root privileges."
    # Load libraries or
    exit 0
fi

declare -A dialogue

# Check if whiptail or dialog is installed and set the variable 'dialogue' accordingly.
# If neither is found, print "TUI not found" and return.
if command -v whiptail &> /dev/null; then
    dialogue="whiptail"
elif command -v dialog &> /dev/null; then
    dialogue="dialog"
else
    echo "TUI not found"
    return
fi

debug="0"
directory="$(dirname "${BASH_SOURCE[0]}")"
cd "$directory" || exit
filename="$(basename "${BASH_SOURCE[0]}")" ;
libpath="$directory/../lib"

for file in "$libpath"/configng/*/*.sh; do
    source "$file"
done

mapfile -t categories < <(ls -d "$libpath/configng"/* )

declare -A functions

for category in "${categories[@]}"; do
    category_name="${category##*/}"

    category_file="$category/category"
    if [[ -f "$category_file" ]]; then
        category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
    fi

    for file in "$category"/*.sh; do
        description=""
        while IFS= read -r line; do
            if [[ $line =~ ^#\ @description\ (.*)$ ]]; then
                description="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^function\ (.*::.*)\(\)\{$ ]]; then
                function_name="${BASH_REMATCH[1]}"
                key="$category_name:${file##*/}:${function_name}"
                functions["$key,function_name"]=$(echo "$function_name" | sed 's/.*:://')
                functions["$key,group_name"]=$(echo "$function_name" | sed 's/::.*//')
                functions["$key,description"]=$description
            elif [[ $line =~ ^#\ @options\ (.*)$ ]]; then
                functions["$key,options"]="${BASH_REMATCH[1]}"
            fi
        done < "$file"
        functions["$key,category"]=$category_name
        functions["$key,category_description"]=$category_description
    done
done


see_debug() {
echo
    for category in "${categories[@]}"; do
        echo "Category: ${category##*/}"
		echo "Category Description: ${functions["$key,category_description"]}"

        for file in "$category"/*.sh; do
            echo "  File: ${file##*/}"

            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                echo "        Full Function Name: ${function} - Description: ${functions["$key,description"]}"
                echo "            Group Name: ${functions["$key,group_name"]}"
                echo "            Action Name: ${functions["$key,function_name"]}"
                echo "            Options: ${functions["$key,options"]}"
            done
        done
		echo
    done
	echo
}

see_json() {
echo
    for category in "${categories[@]}"; do
        echo "Category: ${category##*/}"
		echo "Category Description: ${functions["$key,category_description"]}"

        for file in "$category"/*.sh; do
            echo "  File: ${file##*/}"

            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                echo "        Full Function Name: ${function} - Description: ${functions["$key,description"]}"
                echo "            Group Name: ${functions["$key,group_name"]}"
                echo "            Action Name: ${functions["$key,function_name"]}"
                echo "            Options: ${functions["$key,options"]}"
            done
        done
		echo
    done
	echo
}

# the readme.md is generated from this function
# todo output each category to a file in the docs folder
see_markdown() {
cat << EOF
This is a refactoring of [armbian-config](https://github.com/armbian/config) using [Bash Utility](https://labbots.github.io/bash-utility)
embedded in this project. This allows for functional programming in Bash. Error handling and validation are also included.
The idea is to provide an API in Bash that can be called from a Command line interface, Text User interface and others.
Why Bash? Well, because it's going to be in every distribution. Striped down distributions
may not include Python, C/C++, etc. build/runtime environments

## Quick start
Run the following commands:

        sudo apt install git
        cd ~/
        git clone https://github.com/armbian/configng.git
        bash ~/configng/bin/armbian-configng -h
  
### If all goes well you should see the help message

## Coding Style
follow the following coding style:

    # @description A short description of the function.
    #
    # @exitcode 0  If successful.
    #
    # @options A description if there are options.
    function group::string() {
        echo "hello world"
        return 0
    }
  
# Codestyle can be used to auto generate
 - Markdown
 - JSON
 - Text User Interface
 - Command Line Interface
 - Help message
 - launch a feature
 
EOF

    for category in "${categories[@]}"; do
        echo "## ${category##*/}"
		echo "${functions["$key,category_description"]}"
        echo

        for file in "$category"/*.sh; do
            echo "### ${file##*/}"
            echo

            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                echo " - **Group Name:** ${functions["$key,group_name"]}"
                echo " - **Action Name:** ${functions["$key,function_name"]}"
                echo " - **Options:** ${functions["$key,options"]}"
                echo " - **Description:** ${functions["$key,description"]}"
                echo
            done
        done
    done 

}

see_list() {
    echo
    # Loop through each category
    for category in "${categories[@]}"; do
        # Initialize an empty array to store the group names that have been printed
        declare -A printed_groups

        # Loop through each file in the category
        for file in "$category"/*.sh; do

            # Extract functions from the file
            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            # Loop through each function in the file
            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                group_name=${functions["$key,group_name"]}

                # If the group name has not been printed yet, print it and add it to the array
                declare -A printed_groups
                if [[ -z ${printed_groups["$group_name"]} ]]; then
                    echo "        $group_name,    [action]"
                    printed_groups["$group_name"]=1
                fi

                echo "               ${functions["$key,function_name"]} - ${functions["$key,description"]}"
				echo
            done
        done
		echo
    done
	echo
}

parse_action() {
    local group=$1
    local action=$2

    # Construct the full function name
    local function_name="${group}::${action}"

    # Check if the function exists
    if declare -f "$function_name" > /dev/null; then
        # Return the function name
        echo "$function_name"
    else
        echo "Error: Unknown action '$action' for group '$group'"
        return 1
    fi
}

see_tui() {
    local options=()
    local i=0
    declare -A categories_array
    for category in "${categories[@]}"; do
        local category_name="${category##*/}"
        local category_description=""
        local category_file="$category/category"

        if [[ -f "$category_file" ]]; then
            category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
        fi

        categories_array["$i"]="$category_name"
        description_array["$i"]="$category_description"
        options+=("$i" "${categories_array[$i]} - ${description_array[$i]}")
        ((++i))
    done

    local choice
    choice=$($dialogue --menu "Select a category:" 0 0 9 "${options[@]}" 3>&1 1>&2 2>&3)

    if [[ -n $choice ]]; then
        see_sub_tui "${categories_array[$choice]}"
    fi
}
see_sub_tui() {
   $dialogue --title "Message" --msgbox "$1" 8 50
}

see_read() {
    echo
    echo "Please select an action:"
    echo
    # Initialize an empty array to store the function keys
    declare -a function_keys

    # Loop through each key in the functions array
    local i=1
    local current_category=""
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name" ]]; then
            # Add the key to the function_keys array
            function_keys[i]="${key%,function_name}"

            # Check if the category has changed and display it if so
            local category="${functions["${function_keys[i]},category"]}"
            if [[ "$category" != "$current_category" ]]; then
                echo "Category: $category"
                current_category="$category"
            fi

            # Display the function and its description as an option in the menu
            echo "  $i. ${functions["${function_keys[i]},group_name"]} ${functions[$key]}  - ${functions["${function_keys[i]},description"]}"
            ((i++))
        fi
    done

    echo
    echo "$i. Show help"
    ((i++))
    echo "$i. Exit"

    read -p "Enter your choice: " choice

    if ((choice == i-1)); then
        see_help
        see_list
    elif ((choice == i)); then
        exit 0
    elif ((choice >= 1 && choice <= ${#function_keys[@]})); then
        # Call the selected function using variable indirection
        eval "${functions["${function_keys[choice]},group_name"]}::${functions["${function_keys[choice]},function_name"]}"
    else
        echo "Invalid choice"
    fi
}

see_help(){
cat << EOF 
Usage: ${filename%.*} [flag] [option] [action]"
  flags:
    -h,   Print this help.
    -t,   Show a Text-Base user interface.
    -d,   Show a debug information.
    -m,   Generate a readme.md.
    -j,   show a json ouput. # TODO: output file need usable location
    -r,   [option]  [action]  To run a feature.
EOF
}

if [ "$1" == "-r" ]; then
    shift  # Shifts the arguments to the left, excluding the first argument ("-r")
    group_name="$1"  # Takes the first argument as the group name
    shift 1  # Shifts the arguments again to exclude the group name

    function_name=$(parse_action "$group_name" "$1")
    if [ $? -eq 0 ]; then
        # Call the function using variable indirection
        ${function_name}
    fi

elif [ "$1" == "-h" ]; then
	see_help
	see_list
elif [ "$1" == "-d" ] || [ $debug == "1" ] ; then
	see_debug
	exit
elif [ "$1" == "-t" ] || [ $debug == "1" ] ; then
	see_tui
	exit
elif [ "$1" == "-m" ] || [ $debug == "1" ] ; then
	see_markdown > ../README.md
	exit
else
 	see_read
	exit
fi

