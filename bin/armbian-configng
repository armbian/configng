#!/bin/bash

# This script provides a command-line interface for managing Armbian configuration.
# It loads libraries of functions from the lib directory and displays them in a menu.
# The user can select a function to run, or use a text-based user interface (TUI) to navigate the menus.
# The script also provides a help option and a debug option for developers.
# The script requires sudo privileges to run some functions.
# The script uses whiptail or dialog for the TUI, depending on which is available.

#set -x
clear
#
# Enable Dynamic directory root use home ~/ , /bin , /usr/sbin etc.. 
bin="$(dirname "${BASH_SOURCE[0]}")"
directory="$(cd "$bin/../" && pwd )"
file_name="$(basename "${BASH_SOURCE[0]}")"
filename="${file_name%.*}"
libpath=$(cd "$directory/lib/$filename/" && pwd)
[[ -f "/etc/armbian-release" ]] && source /etc/armbian-release
[[ -f "/etc/os-release" ]] && source /etc/os-release
[[ -f "$libpath/set_get_system.sh" ]] && source "$libpath/set_get_system.sh" 



#
# Check if the script is dev version.
[[ "$1" == "--dev" ]] && dev=1 && shift 1 

suffix="${file_name##*-}"

if [[ "$suffix" == dev ]]; then
    dev=1
    check_distro 
fi

if [[ "$(id -u)" != "0" ]] && [[ "$dev" == "1" ]] ; then

cat << EOF #| ./armbian-interface -o
I: Running in UX development mode
W: Admin functions will not work as expected

EOF
elif [[ "$(id -u)" == "0" ]] && [[ "$dev" == "1" ]] ; then
cat << EOF #| ./armbian-interface -o
I: Running in UX development mode
W: Document files may need Admin privleges to edit/remove

EOF

fi

#
# Check if the script is being run as root
# UX Development mode bypasses root check, many functions will not work as expected

if [[ "$(id -u)" != "0" ]] && [[ "$dev" != "1" ]]; then
    echo -e "E: This tool requires root privileges. Try: \"sudo $filename\"" >&2
    exit 1
fi

# get_config
# see_ping
is_apt_list_current

declare -A dialogue

#
# Check if whiptail or dialog is installed and set the variable 'dialogue' accordingly.
# todo add a fallback TUI and GUI
if command -v whiptail &> /dev/null; then
    dialogue="whiptail"
elif command -v dialog &> /dev/null; then
    dialogue="dialog"
else
    dialogue="$file_name"
fi

if [ -f "$libpath/documents.sh" ]; then
    source "$libpath/documents.sh"
fi

# load the group functions
for file in "$libpath"/*/*.sh; do
    source "$file"
done

#
mapfile -t categories < <(find "$libpath"/* -type d)
declare -A functions

for category in "${categories[@]}"; do
    category_name="${category##*/}"
    category_file="$category/category.conf"
    if [[ -f "$category_file" ]]; then
        category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
    fi
    for file in "$category"/*.sh; do
        description=$(grep -oP "(?<=# @description ).*" "$file")
        options=$(grep -oP "(?<=# @options ).*" "$file")
        default=$(grep -oP "(?<=# @default ).*" "$file")
        require=$(grep -oP "(?<=# @requirments ).*" "$file")
        while IFS= read -r line; do
            if [[ $line =~ ^function\ (.*::.*)\(\)\{$ ]]; then
                function_name="${BASH_REMATCH[1]}"
                key="$category_name:${file##*/}:${function_name}"
                functions["$key,function_name"]=$(echo "$function_name" | sed 's/.*:://')
                functions["$key,group_name"]=$(echo "$function_name" | sed 's/::.*//')
                functions["$key,description"]=$description
                functions["$key,default" ]="$default"
                IFS= read -r functions["$key,options"] <<< "$options"
                # Set the toggle array based on the options
                if [[ $options == "none" ]]; then
                    functions["$key,toggle"]="none"
                else
                    functions["$key,toggle"]="$default"
                fi
            fi
        done < "$file"
        functions["$key,category"]=$category_name
        functions["$key,category_description"]=$category_description
    done
done

###############################################################################################
###############################################################################################

# This function is used to generate a text-based user interface (TUI) for navigating the menus.
generate_tui() {
    local options=()
    local i=0
    declare -A categories_array
    local help_index=-1

    for category in "${categories[@]}"; do
        local category_name="${category##*/}"
        local category_description=""
        local category_file="$category/category.conf"

        if [[ -f "$category_file" ]]; then
            category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
        fi

        if [[ "$category_name" == "help" ]]; then
            help_index=$i
        else
            categories_array["$i"]="$category_name"
            description_array["$i"]="$category_description"
            options+=("$i" "$(printf '%-7s - %-8s' "${categories_array[$i]}" "${description_array[$i]}")")
            ((++i))
        fi
    done

    # Add the help category if it exists
    if [[ $help_index -ne -1 ]]; then
        categories_array["$i"]="help"
        description_array["$i"]="Documentation, support, sources"
        options+=("$i" "$(printf '%-7s - %-8s' "${categories_array[$i]}" "${description_array[$i]}")")
        ((++i))
    fi

    [[ -f /sbin/armbian-config ]] && options+=("$i" "$(printf '%-7s - %-8s' "Legacy" "Run Legacy configuration")") ; ((++i)) ;
    [[ ! -d "$libpath/help" ]] && options+=("$i" "$(printf '%-7s - %-8s' "Help" "Documentation, support, sources")") ; ((++i)) ;

    local choice
    choice=$($dialogue --menu "Select a category:" 0 0 9 "${options[@]}" 3>&1 1>&2 2>&3)
    
    if [[ -n $choice ]]; then
        if ((choice == "$i - 1")); then
            generate_help ;
            echo "" ;
            generate_list_cli ; 
            exit 0 ;
        elif ((choice == "$i - 2")); then
            armbian-config
            exit ;
        else
            generate_sub_tui "${categories_array[$choice]}"
        fi
    fi
}

# This function is used to generate a text-based user interface (TUI) for navigating the menus.
generate_sub_tui() {
    local category="$1"
    local options=()
    local i=0
    declare -A functions_array
    for file in "$libpath/$category"/*.sh; do
        mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")
        for function in "${functions_in_file[@]}"; do
            key="${category##*/}:${file##*/}:${function}"
            functions_array["$i"]="$function"
            options+=("$i" "${functions["$key,function_name"]} - ${functions["$key,description"]}")
            ((++i))
        done
    done

    local choice
    
    choice=$($dialogue --menu "Select a function:" 0 0 9 "${options[@]}" 3>&1 1>&2 2>&3)
    
    if [[ -n $choice ]]; then
        generate_action "${functions_array[$choice]}" | "$directory/bin/armbian-interface" -o
    fi

}

# This function is used to generate a whiptail/dialog text-based user interface (TUI) for navigating the menus.
generate_action() {
    local function_name="$1"
            ${function_name}
}

# This function is used to generate a bash text-based user interface (TUI) for navigating the menus.
generate_read() {
    echo
    echo "Please select an action:"
    echo
    # Initialize an empty array to store the function keys
    declare -a function_keys

    # Loop through each key in the functions array
    local i=1
    local current_category=""
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name" ]]; then
            # Add the key to the function_keys array
            function_keys[i]="${key%,function_name}"

            # Check if the category has changed and display it if so
            local category="${functions["${function_keys[i]},category"]}" # < editor"
            if [[ "$category" != "$current_category" ]]; then
                echo " $category"
                current_category="$category"
            fi

            # Display the function and its description as an option in the menu
            echo "  $i. ${functions["${function_keys[i]},group_name"]} ${functions[$key]}  - ${functions["${function_keys[i]},description"]}" #" < for my editor
            ((i++))
        fi
    done

    echo
    #echo "$i. Show help"
    #((i++))
    echo "$i. Exit"

    read -p "Enter your choice: " choice

    if ((choice == i-1)); then
        generate_help ; 
    elif ((choice == i)); then
        exit 0
    elif ((choice >= 1 && choice <= ${#function_keys[@]})); then
        # Call the selected function using variable indirection
        eval "${functions["${function_keys[choice]},group_name"]}::${functions["${function_keys[choice]},function_name"]}" #" < for my editor
    else
        echo "Invalid choice"
    fi
}

# This function is used to parse the action name and return the full function name.
parse_action() {
    local group=$1
    local action=$2

    # Construct the full function name
    local function_name="${group}::${action}"

    # Check if the function exists
    if declare -f "$function_name" > /dev/null; then
        # Return the function name
        echo "$function_name"
    else
        echo "Error: Unknown action '$action' for group '$group'"
        return 1
    fi
}
###############################################################################################
# WIP: Check arguments for no flag options
# armbian-config --help
# Change to BASH: /usr/sbin/armbian-config main=System selection=BASH
handle_no_flag(){
    if [[ "$1" == *"="* ]]; then
        IFS='=' read -r key value <<< "$1"
        function_name=$(parse_action "$key" "$value")
        # Call the function using variable indirection
        ${function_name}
    elif [[ "$1" == "help"* ]]; then
        generate_list_cli
    fi
}

#
# Check arguments for long flag options
# Help message related to the functions the back end
handle_long_flag(){
    if [[ "$1" == "--help" ]]; then
        generate_help
        exit 0 ;
    elif [[ "$1" == "--menu" ]]; then
    generate_read ; exit 0 ; 
        exit 0 ;
    elif [[ "$1" == "--doc" ]]; then
        generate_doc
        exit 0 ;
    elif [[ "$1" == "--server" ]]; then
        serve_and_open_html
        exit 0 ;
    elif [[ "$1" == "--web" ]]; then
        generate_web
        exit 0 ;
    elif [[ "$1" == "--json" ]]; then
        generate_json
        exit 0 ;
    elif [[ "$1" == "--csv" ]]; then
        generate_csv
        exit 0 ;
    fi

# WIP: 
    if [ "$1" == "--run" ]; then
        shift  # Shifts the arguments to the left, excluding the first argument ("-r")
        group_name="$1"  # Takes the first argument as the group name
        shift 1  # Shifts the arguments again to exclude the group name

        function_name=$(parse_action "$group_name" "$1")
        if [ $? -eq 0 ]; then
            # Call the function using variable indirection
            ${function_name}
        fi
    fi

}
#
# Check arguments for short flag options
# THe interface help message 
handle_short_flag(){
if [ "$1" == "-h" ]; then
    generate_help
    exit 0 ;
# Generate a text-based user interface
elif [ "$1" == "-t" ]  ; then
    generate_read ; exit 0 ;    
# Generate all doc files
elif [ "$1" == "-d" ] ; then
    generate_doc ; exit 0 ;
elif [ "$1" == "-j" ] ; then
    generate_json ; exit 0 ;
fi

}

case "$1" in
    *"="*)
        # Handle the case where $1 contains "="
        handle_no_flag "$@"
        ;;
    *"--"*)
        # Handle the case where $1 starts with "--"
        handle_long_flag "$@"
        ;;
    *"-"*)
        # Handle the case where $1 starts with "-"
        handle_short_flag "$1"
        ;;
    *)
        handle_no_flag "$@"
        # Handle the case where $1 does not match any of the above patterns
        # You can add your code here
        ;;
esac

if [[ -z "$1" ]] ; then
 
while true; do
    if [[ "$dialogue" == "$file_name" ]]; then
        generate_read
    elif [[ "$dialogue" != "$file_name" ]]; then
        generate_tui 
    fi

    if [[ "$?" == "0" ]]; then
        break
    fi
done
   
fi