#!/bin/bash

# This script provides a command-line interface for managing Armbian configuration.
# It loads libraries of functions from the lib directory and displays them in a menu.
# The user can select a function to run, or use a text-based user interface (TUI) to navigate the menus.
# The script also provides a help option and a debug option for developers.
# The script requires sudo privileges to run some functions.
# The script uses whiptail or dialog for the TUI, depending on which is available.

# TODO: Add more detailed documentation for each function and option in the script.

clear
# Sudo Users Home

if [ "$(id -u)" = "0" ]; then
    # This block is executed if the script is run with sudo
    # echo "Running with root privileges."
    USER_HOME=$(eval echo ~"$SUDO_USER")
else
    # This block is executed if the script is not run with sudo
    printf '%s\n' "Running without root privileges."
    # Load libraries or
    exit 0
fi

declare -A dialogue

if command -v whiptail &> /dev/null; then
    dialogue="whiptail"
elif command -v dialog &> /dev/null; then
    dialogue="dialog"
else
    echo "TUI not found"
    return
fi

debug="0"
directory="$(dirname "${BASH_SOURCE[0]}")"
cd "$directory" || exit
filename="$(basename "${BASH_SOURCE[0]}")" ;
libpath="$directory/../lib"

for file in "$libpath"/configng/*/*.sh; do
    source "$file"
done

mapfile -t categories < <(ls -d "$libpath/configng"/* )

declare -A functions

for category in "${categories[@]}"; do
    category_name="${category##*/}"

    category_file="$category/category"
    if [[ -f "$category_file" ]]; then
        category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
    fi

    for file in "$category"/*.sh; do
        description=""
        while IFS= read -r line; do
            if [[ $line =~ ^#\ @description\ (.*)$ ]]; then
                description="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^function\ (.*::.*)\(\)\{$ ]]; then
                function_name="${BASH_REMATCH[1]}"
                key="$category_name:${file##*/}:${function_name}"
                functions["$key,function_name"]=$(echo "$function_name" | sed 's/.*:://')
                functions["$key,group_name"]=$(echo "$function_name" | sed 's/::.*//')
                functions["$key,description"]=$description
            elif [[ $line =~ ^#\ @options\ (.*)$ ]]; then
                functions["$key,options"]="${BASH_REMATCH[1]}"
            fi
        done < "$file"
        functions["$key,category"]=$category_name
        functions["$key,category_description"]=$category_description
    done
done

see_debug() {
echo
    for category in "${categories[@]}"; do
        echo "Category: ${category##*/}"
		echo "Category Description: ${functions["$key,category_description"]}"

        for file in "$category"/*.sh; do
            echo "  File: ${file##*/}"

            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                echo "        Full Function Name: ${function} - Description: ${functions["$key,description"]}"
                echo "            Group Name: ${functions["$key,group_name"]}"
                echo "            Action Name: ${functions["$key,function_name"]}"
                echo "            Options: ${functions["$key,options"]}"
            done
        done
		echo
    done
	echo
}

see_readme() {
echo
    for category in "${categories[@]}"; do
        echo "## ${category##*/}"
		echo "${functions["$key,category_description"]}"
        echo

        for file in "$category"/*.sh; do
            echo "### ${file##*/}"
            echo

            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                echo " - **Group Name:** ${functions["$key,group_name"]}"
                echo " - **Action Name:** ${functions["$key,function_name"]}"
                echo " - **Options:** ${functions["$key,options"]}"
                echo " - **Description:** ${functions["$key,description"]}"
                echo
            done
        done
		echo
    done
	echo
}

see_list() {
    echo
    # Loop through each category
    for category in "${categories[@]}"; do
        # Initialize an empty array to store the group names that have been printed
        declare -A printed_groups

        # Loop through each file in the category
        for file in "$category"/*.sh; do

            # Extract functions from the file
            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            # Loop through each function in the file
            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                group_name=${functions["$key,group_name"]}

                # If the group name has not been printed yet, print it and add it to the array
                declare -A printed_groups
                if [[ -z ${printed_groups["$group_name"]} ]]; then
                    echo "        $group_name,    [action]"
                    printed_groups["$group_name"]=1
                fi

                echo "               ${functions["$key,function_name"]} - ${functions["$key,description"]}"
				echo
            done
        done
		echo
    done
	echo
}

see_help(){
cat << EOF 
Usage: ${filename%.*} [flag] [option] [action]"
  flags:
    -h,   Print this help.
    -t,   Show a Text-Base user interface.
    -d,   Show a debug information.
    -m,   show a Markdown readme.
    -r,   [option]  [action]  To run a feature.
EOF
}

parse_action() {
    local group=$1
    local action=$2

    # Construct the full function name
    local function_name="${group}::${action}"

    # Check if the function exists
    if declare -f "$function_name" > /dev/null; then
        # Return the function name
        echo "$function_name"
    else
        echo "Error: Unknown action '$action' for group '$group'"
        return 1
    fi
}

see_tui() {
    local options=()
    local i=0
    declare -A categories_array
    for category in "${categories[@]}"; do
        local category_name="${category##*/}"
        local category_description=""
        local category_file="$category/category"

        if [[ -f "$category_file" ]]; then
            category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
        fi

        categories_array["$i"]="$category_name"
        description_array["$i"]="$category_description"
        options+=("$i" "${categories_array[$i]} - ${description_array[$i]}")
        ((++i))
    done

    local choice
    choice=$($dialogue --menu "Select a category:" 0 0 9 "${options[@]}" 3>&1 1>&2 2>&3)

    if [[ -n $choice ]]; then
        see_sub_tui "${categories_array[$choice]}"
    fi
}

see_sub_tui() {
    # Get the folder name as an argument
    local folder_name=$1

    # Loop through all keys in the functions array
    for key in "${!functions[@]}"; do
        # If the key starts with the folder name
        if [[ $key == "$folder_name"* ]]; then
            # Extract the group name and description from the functions array
            local group_name=${functions["$key,group_name"]}
            local description=${functions["$key,description"]}

            # Print the group name and description
            echo "Group Name: $group_name"
            echo "Description: $description"
            echo
        fi
    done
}

see_sub_tui_1() {
   $dialogue --title "Message" --msgbox "$1" 8 50
}

see_read() {
    echo
    echo "Please select an action:"
    echo
    # Initialize an empty array to store the function keys
    declare -a function_keys

    # Loop through each key in the functions array
    local i=1
    local current_category=""
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name" ]]; then
            # Add the key to the function_keys array
            function_keys[i]="${key%,function_name}"

            # Check if the category has changed and display it if so
            local category="${functions["${function_keys[i]},category"]}"
            if [[ "$category" != "$current_category" ]]; then
                see_sub_tui_1 "$(see_sub_tui "$category")"
                current_category="$category"
            fi
        fi
    done
}
see_sub_tui_1() {
   $dialogue --title "Message" --msgbox "$1" 8 50
}

see_read() {
    echo
    echo "Please select an action:"
    echo
    # Initialize an empty array to store the function keys
    declare -a function_keys

    # Loop through each key in the functions array
    local i=1
    local current_category=""
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name" ]]; then
            # Add the key to the function_keys array
            function_keys[i]="${key%,function_name}"

            # Check if the category has changed and display it if so
            local category="${functions["${function_keys[i]},category"]}"
            if [[ "$category" != "$current_category" ]]; then
                echo "Category: $category"
                current_category="$category"
            fi

            # Display the function and its description as an option in the menu
            echo "  $i. ${functions["${function_keys[i]},group_name"]} ${functions[$key]}  - ${functions["${function_keys[i]},description"]}"
            ((i++))
        fi
    done

    echo
    echo "$i. Show help"
    ((i++))
    echo "$i. Exit"

    read -p "Enter your choice: " choice

    if ((choice == i-1)); then
        see_help
        see_list
    elif ((choice == i)); then
        exit 0
    elif ((choice >= 1 && choice <= ${#function_keys[@]})); then
        # Call the selected function using variable indirection
        eval "${functions["${function_keys[choice]},group_name"]}::${functions["${function_keys[choice]},function_name"]}"
    else
        echo "Invalid choice"
    fi
}



if [ "$1" == "-r" ]; then
    shift  # Shifts the arguments to the left, excluding the first argument ("-r")
    group_name="$1"  # Takes the first argument as the group name
    shift 1  # Shifts the arguments again to exclude the group name

    function_name=$(parse_action "$group_name" "$1")
    if [ $? -eq 0 ]; then
        # Call the function using variable indirection
        ${function_name}
    fi

elif [ "$1" == "-h" ]; then
	see_help
	see_list
elif [ "$1" == "-d" ] || [ $debug == "1" ] ; then
	see_debug
	exit
elif [ "$1" == "-t" ] || [ $debug == "1" ] ; then
	see_tui
	exit
elif [ "$1" == "-m" ] || [ $debug == "1" ] ; then
	see_readme
	exit
else
 	see_read
	exit
fi

