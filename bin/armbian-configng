#!/bin/bash

# This script provides a command-line interface for managing Armbian configuration.
# It loads libraries of functions from the lib directory and displays them in a menu.
# The user can select a function to run, or use a text-based user interface (TUI) to navigate the menus.
# The script also provides a help option and a debug option for developers.
# The script requires sudo privileges to run some functions.
# The script uses whiptail or dialog for the TUI, depending on which is available.

#set -x
clear
#
# Enable Dynamic directory root use home ~/ , /bin , /usr/sbin etc.. 
bin="$(dirname "${BASH_SOURCE[0]}")"
directory="$(cd "$bin/../" && pwd )"
file_name="$(basename "${BASH_SOURCE[0]}")"
filename="${file_name%.*}"
libpath=$(cd "$directory/lib/$filename/" && pwd)
[[ -f "/etc/armbian-release" ]] && source /etc/armbian-release
[[ -f "/etc/os-release" ]] && source /etc/os-release
[[ -f "$libpath/set_get_system.sh" ]] && source "$libpath/set_get_system.sh" 

#
# Check if the script is dev version.
[[ "$1" == "--dev" ]] && dev=1 && shift 1 

suffix="${file_name##*-}"

if [[ "$suffix" == dev ]]; then
    dev=1
    check_distro 
fi

if [[ "$(id -u)" != "0" ]] && [[ "$dev" == "1" ]] ; then

cat << EOF #| ./armbian-interface -o
I: Running in UX development mode
W: Admin functions will not work as expected

EOF
elif [[ "$(id -u)" == "0" ]] && [[ "$dev" == "1" ]] ; then
cat << EOF #| ./armbian-interface -o
I: Running in UX development mode
W: Document files may need Admin privleges to edit/remove

EOF

fi

#
# Check if the script is being run as root
# UX Development mode bypasses root check, many functions will not work as expected

if [[ "$(id -u)" != "0" ]] && [[ "$dev" != "1" ]]; then
    echo -e "E: This tool requires root privileges. Try: \"sudo $filename\"" >&2
    exit 1
fi

declare -A dialogue

#
# Check if whiptail or dialog is installed and set the variable 'dialogue' accordingly.
# todo add a fallback TUI and GUI
if command -v whiptail &> /dev/null; then
    dialogue="whiptail"
elif command -v dialog &> /dev/null; then
    dialogue="dialog"
else
    dialogue="$file_name"
fi

if [ -f "$libpath/documents.sh" ]; then
    source "$libpath/documents.sh"
fi

# load the group functions
for file in "$libpath"/*/*.sh; do
    source "$file"
done

#
mapfile -t categories < <(find "$libpath"/* -type d)
declare -A functions

for category in "${categories[@]}"; do
    category_name="${category##*/}"
    category_file="$category/category.conf"
    if [[ -f "$category_file" ]]; then
        category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
    fi
    for file in "$category"/*.sh; do
        description=$(grep -oP "(?<=# @description ).*" "$file")
        options=$(grep -oP "(?<=# @options ).*" "$file")
        default=$(grep -oP "(?<=# @default ).*" "$file")
        require=$(grep -oP "(?<=# @requirments ).*" "$file")
        while IFS= read -r line; do
            if [[ $line =~ ^function\ (.*::.*)\(\)\{$ ]]; then
                function_name="${BASH_REMATCH[1]}"
                key="$category_name:${file##*/}:${function_name}"
                functions["$key,function_name"]=$(echo "$function_name" | sed 's/.*:://')
                functions["$key,group_name"]=$(echo "$function_name" | sed 's/::.*//')
                functions["$key,description"]=$description
                functions["$key,default" ]="$default"
                IFS= read -r functions["$key,options"] <<< "$options"
                # Set the toggle array based on the options
                if [[ $options == "none" ]]; then
                    functions["$key,toggle"]="none"
                else
                    functions["$key,toggle"]="$default"
                fi
            fi
        done < "$file"
        functions["$key,category"]=$category_name
        functions["$key,category_description"]=$category_description
    done
done

# This function is used to generate a whiptail/dialog text-based user interface (TUI) for navigating the menus.
generate_action() {
    local function_name="$1"
            ${function_name}
}


generate_help(){

#Usage: ${filename%.*} [flag][option]

    cat << EOF
    
Usage: ${0##*/} [OPTION]...
    options:
        -h, --help    Show this help message and exit
        -d, --doc     Generate documentation
        -t, --menu    Generate Text-based user interface (TUI)
        --deps        Check dependencies are installed and install if not
        --web         Generate debug web page 
        --json        Generate JSON
        --csv         Generate CSV
        --server      Serve and open HTML

      example:
        ${0##*/} --deps git  
    
  
     
    options:   
         help         Advanced no-interface options help message

    $( generate_list_cli )

    This will parse the command to the Group function, and the function will be run.

    example:
       ${0##*/} [group]=[function]

EOF

}


# This function is used to generate a bash text-based user interface (TUI) for navigating the menus.
generate_read() {
    echo
    echo "Please select an action:"
    echo
    # Initialize an empty array to store the function keys
    declare -a function_keys

    # Loop through each key in the functions array
    local i=1
    local current_category=""
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name" ]]; then
            # Add the key to the function_keys array
            function_keys[i]="${key%,function_name}"

            # Check if the category has changed and display it if so
            local category="${functions["${function_keys[i]},category"]}" # < editor"
            if [[ "$category" != "$current_category" ]]; then
                #echo "  $category"
                current_category="$category"
            fi

            # Display the function and its description as an option in the menu
            echo "$i. ${functions["${function_keys[i]},group_name"]} ${functions[$key]}  - ${functions["${function_keys[i]},description"]}" #" < for my editor
            ((i++))
        fi
    done

    echo
    #echo "$i. Show help"
    echo "$i. Exit"

    read -p "Enter your choice: " choice

    if ((choice == i)); then
        exit 0
    elif ((choice >= 1 && choice <= ${#function_keys[@]})); then
        # Call the selected function using variable indirection
        eval "${functions["${function_keys[choice]},group_name"]}::${functions["${function_keys[choice]},function_name"]}" #" < for my editor
    else
        echo "Invalid choice"
    fi
}

# This function is used to parse the action name and return the full function name.
parse_action() {
    local group=$1
    local action=$2

    # Construct the full function name
    local function_name="${group}::${action}"

    # Check if the function exists
    if declare -f "$function_name" > /dev/null; then
        # Return the function name
        echo "$function_name"
    else
        echo "Error: Unknown action '$action' for group '$group'"
        return 1
    fi
}

###############################################################################################
# WIP: Check arguments for no flag options
# armbian-config --help
# Change to BASH: /usr/sbin/armbian-config main=System selection=BASH
handle_no_flag(){
    if [[ "$1" == *"="* ]]; then
        IFS='=' read -r key value <<< "$1"
        function_name=$(parse_action "$key" "$value")
        # Call the function using variable indirection
        ${function_name}
    elif [[ "$1" == "help"* ]]; then
        generate_list_cli
    fi
}

#
# Check arguments for long flag options
# Help message related to the functions the back end
run_long_flag(){
# WIP: 
    if [ "$1" == "--run" ]; then
        shift  # Shifts the arguments to the left, excluding the first argument ("-r")
        group_name="$1"  # Takes the first argument as the group name
        shift 1  # Shifts the arguments again to exclude the group name

        function_name=$(parse_action "$group_name" "$1")
        if [ $? -eq 0 ]; then
            # Call the function using variable indirection
            ${function_name}
        fi
    fi

}

#
# Check arguments for short flag options
# THe interface help message 
handle_short_flag(){

    if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
        generate_help
        exit 0 ;
    elif [[ "$1" == "--menu" ]] || [[ "$1" == "-t" ]]; then
        see_ping
        is_apt_list_current
        generate_read ; exit 0 ; 
        exit 0 ;
    elif [[ "$1" == "--doc" ]] || [[ "$1" == "-d" ]]; then
        see_ping
        is_apt_list_current
        see_get_dependencies pandoc git || exit 1
        generate_doc
        exit 0 ;
    elif [[ "$1" == "--deps" ]] ; then
        shift
        check_dependencies "${@}"
        exit 0 ;
    elif [[ "$1" == "--server" ]]; then
        serve_and_open_html
        exit 0 ;
    elif [[ "$1" == "--web" ]]; then
        generate_web
        exit 0 ;
    elif [[ "$1" == "--json" ]]; then
        generate_json
        exit 0 ;
    elif [[ "$1" == "--csv" ]]; then
        generate_csv
        exit 0 ;
    fi

}

case "$1" in
    *"="*)
        # Handle the case where $1 contains "="
        handle_no_flag "$@"
        ;;
    *"--"*)
        # Handle the case where $1 starts with "--"
        handle_short_flag "$@"
        ;;
    *"-"*)
        # Handle the case where $1 starts with "-"
        handle_short_flag "$1"
        ;;
    *)
        handle_no_flag "$@"
        # Handle the case where $1 does not match any of the above patterns
        # You can add your code here
        ;;
esac
