#!/bin/bash

# This script provides a command-line interface for managing Armbian configuration.
# It loads libraries of functions from the lib directory and displays them in a menu.
# The user can select a function to run, or use a text-based user interface (TUI) to navigate the menus.
# The script also provides a help option and a debug option for developers.
# The script requires sudo privileges to run some functions.
# The script uses whiptail or dialog for the TUI, depending on which is available.

# TODO: Add more detailed documentation for each function and option in the script.

# Sudo Users Home use to output local
if [ "$(id -u)" = "0" ]; then
    USER_HOME=$(eval echo ~"$SUDO_USER")
fi

declare -A dialogue

# Check if whiptail or dialog is installed and set the variable 'dialogue' accordingly.
# If neither is found, print "TUI not found" and return.
if command -v whiptail &> /dev/null; then
    dialogue="whiptail"
#elif command -v dialog &> /dev/null; then
 #   dialogue="dialog"
else
    echo "TUI not found
	Warning: Using fallback TUI"
fi

debug="0"
directory="$(dirname "${BASH_SOURCE[0]}")"
cd "$directory" || exit
filename="$(basename "${BASH_SOURCE[0]}")" ;
libpath="$directory/../lib"

for file in "$libpath"/"$filename"/*/*.sh; do
    source "$file"
done

mapfile -t categories < <(ls -d "$libpath/armbian-configng"/* )

declare -A functions

for category in "${categories[@]}"; do
    category_name="${category##*/}"

    category_file="$category/readme.md"
    if [[ -f "$category_file" ]]; then
        category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
    fi

    for file in "$category"/*.sh; do
        description=""
        while IFS= read -r line; do
            if [[ $line =~ ^#\ @description\ (.*)$ ]]; then
                description="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^function\ (.*::.*)\(\)\{$ ]]; then
                function_name="${BASH_REMATCH[1]}"
                key="$category_name:${file##*/}:${function_name}"
                functions["$key,function_name"]=$(echo "$function_name" | sed 's/.*:://')
                functions["$key,group_name"]=$(echo "$function_name" | sed 's/::.*//')
                functions["$key,description"]=$description
            elif [[ $line =~ ^#\ @options\ (.*)$ ]]; then
                functions["$key,options"]="${BASH_REMATCH[1]}"
            fi
        done < "$file"
        functions["$key,category"]=$category_name
        functions["$key,category_description"]=$category_description
    done
done

see_json() {
    json_objects=()
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name"* ]]; then
            function_key="${key%,function_name}"
            function_name="${functions[$key]}"
            group_name="${functions["$function_key,group_name"]}"
            description="${functions["$function_key,description"]}"
            options="${functions["$function_key,options"]}"
            category="${functions["$function_key,category"]}"
            category_description="${functions["$function_key,category_description"]}"
            json_objects+=("{ \"Function Name\": \"$function_name\", \"Group Name\": \"$group_name\", \"Description\": \"$description\", \"Options\": \"$options\", \"Category\": \"$category\", \"Category Description\": \"$category_description\" }")
        fi
    done
    IFS=','
    echo "[${json_objects[*]}]" | jq
}

# Untested idea is to use the json output to generate a html page
see_html5() {

html5_content='
<!DOCTYPE html>
<html>
<head>
    <title>
		Armbian '$(echo "$filename")' </title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #222;
            color: #fff;
        }
        .slider {
            width: 100%;
            height: 300px;
            overflow: hidden;
            background-color: #333;
        }
        .slide {
            width: 100%;
            height: 300px;
            transition: all 1s ease;
            background-color: #444;
        }
    </style>
</head>
<body>
    <header>
        <h1>'$(echo "$filename")'</h1>
    </header>
    <nav>
        <ul>
            <!-- MENU -->
        </ul>
    </nav>
    <section class="slider">
        <div class="slide-show">
            <!-- SLIDES -->
        </div>
    </section>

<script>
		var slideIndex = 0;
		var jsonData = [{
				id: "slide1",
				heading: "heading 1",
				content: "Slide 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi. Proin porttitor, orci nec nonummy molestie, enim est eleifend mi, non"
			},
			{
				id: "slide2",
				heading: "heading 2",
				content: "Slide 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi. Proin porttitor, orci nec nonummy molestie, enim est eleifend mi, non"
			},
			{
				id: "slide3",
				heading: "heading 3",
				content: "Slide 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi. Proin porttitor, orci nec nonummy molestie, enim est eleifend mi, non"
			},
			{
				id: "slide4",
				heading: "heading 4",
				content: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.    this is the fallback content for slide 4"
			},
			{
				id: "slide5",
				heading: "heading 5",
				content: "this is the fallback content for slide 5"
			}
		]

		function showSlides() {
			var slides = document.querySelectorAll(".slide");
			var navItems = document.querySelectorAll("nav ul li");
			for (var i = 0; i < slides.length; i++) {
				slides[i].style.display = "none";
				navItems[i].classList.remove("active");
			}
			slideIndex++;
			if (slideIndex > slides.length) {
				slideIndex = 1;
			}
			slides[slideIndex - 1].style.display = "block";
			navItems[slideIndex - 1].classList.add("active");
			setTimeout(showSlides, 5000);
		}

		function createSlides() {
			var slideShow = document.querySelector(".slide-show");
			var nav = document.querySelector("nav ul");
			for (var i = 0; i < jsonData.length; i++) {
				var slide = document.createElement("div");
				slide.classList.add("slide");
				slide.id = jsonData[i].id;
				var heading = document.createElement("H2");
				heading.innerHTML = jsonData[i].heading;
				var content = document.createElement("p");
				content.innerHTML = jsonData[i].content;
				slide.appendChild(heading);
				slide.appendChild(content);
				slideShow.appendChild(slide);
				var navItem = document.createElement("li");
				navItem.innerHTML = jsonData[i].heading;
				navItem.setAttribute("data-slide", jsonData[i].id);
				navItem.addEventListener("click", function() {
					var slideId = this.getAttribute("data-slide");
					slideIndex = slideId.split("slide")[1];
					showSlides();
				});
				nav.appendChild(navItem);
			}
			// Add fallback content for each slide
			var fallbackContent = document.createElement("p");
			fallbackContent.innerHTML = "This is the fallback content for the slide.";
			slideShow.appendChild(fallbackContent);
			showSlides();
		}
		createSlides();
</script>


</body>
</html>
'

echo "$html5_content" ;

}

# Simple table for github.io pages
see_html() {
    html_content='<!DOCTYPE html>
    <html>
    <head>
        <style>
            body {
                background-color: #333;
                color: #fff;
                font-family: Arial, sans-serif;
            }
            table {
                border-collapse: collapse;
                width: 100%;
            }
            th, td {
                text-align: left;
                padding: 8px;
            }
            th {
                background-color: #4CAF50;
                color: white;
            }
            tr:nth-child(even) {background-color: #f2f2f2;}
        </style>
    </head>
    <body>
        <table>
            <thead>
                <tr>
                    <th>Function Name</th>
                    <th>Group Name</th>
                    <th>Description</th>
                    <th>Options</th>
                    <th>Category</th>
                    <th>Category Description</th>
                </tr>
            </thead>
            <tbody>'
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name"* ]]; then
            function_key="${key%,function_name}"
            function_name="${functions[$key]}"
            group_name="${functions["$function_key,group_name"]}"
            description="${functions["$function_key,description"]}"
            options="${functions["$function_key,options"]}"
            category="${functions["$function_key,category"]}"
            category_description="${functions["$function_key,category_description"]}"
            html_content+="<tr><td>$function_name</td><td>$group_name</td><td>$description</td><td>$options</td><td>$category</td><td>$category_description</td></tr>"
        fi
    done
    html_content+='
            </tbody>
        </table>
    </body>
    </html>'
    echo "$html_content"
}

# This function is used to generate a list of all functions and their descriptions.
see_debug() {
echo
    for category in "${categories[@]}"; do
        echo "Category: ${category##*/}"
		echo "Category Description: ${functions["$key,category_description"]}"

        for file in "$category"/*.sh; do
            echo "  File: ${file##*/}"

            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                echo "        Full Function Name: ${function} - Description: ${functions["$key,description"]}"
                echo "            Group Name: ${functions["$key,group_name"]}"
                echo "            Action Name: ${functions["$key,function_name"]}"
                echo "            Options: ${functions["$key,options"]}"
            done
        done
		echo
    done
	echo
}

# the readme.md is generated from this function
see_markdown() {
cat << EOF
# Armbian ConfigNG 
Refactor of [armbian-config](https://github.com/armbian/config)       
## relaease 
2021-09-01
# User guide
## Quick start
Run the following commands:
~~~
sudo apt install git
cd ~/
git clone https://github.com/armbian/configng.git
bash ~/configng/bin/armbian-configng -h
~~~  
If all goes well you should see the Text-Based User Inerface (TUI)

### To see a list of all functions and their descriptions, run the following command:
~~~
bash ~/configng/bin/armbian-configng -h
~~~
## Coding Style
follow the following coding style:
~~~
# @description A short description of the function.
#
# @exitcode 0  If successful.
#
# @options A description if there are options.
function group::string() {
    echo "hello world"
    return 0
}
 ~~~ 
## Codestyle can be used to auto generate
 - Markdown
 - JSON
 - Text User Interface
 - Command Line Interface
 - Help message
 - launch a feature

## Up to date list of functions 
EOF

    for category in "${categories[@]}"; do
        echo "## ${category##*/}"
		echo "${functions["$key,category_description"]}"
        echo

        for file in "$category"/*.sh; do
            echo "### ${file##*/}"
            echo

            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                echo " - **Group Name:** ${functions["$key,group_name"]}"
                echo " - **Action Name:** ${functions["$key,function_name"]}"
                echo " - **Options:** ${functions["$key,options"]}"
                echo " - **Description:** ${functions["$key,description"]}"
                echo
            done
        done
    done 
cat << EOF

# Inclueded projects
[Bash Utility (https://labbots.github.io/bash-utility) 

 This allows for functional programming in Bash. Error handling and validation are also included.
The idea is to provide an API in Bash that can be called from a Command line interface, Text User interface and others.

 Why Bash? Well, because it's going to be in every distribution. Striped down distributions
may not include Python, C/C++, etc. build/runtime environments )

EOF
}

see_list() {
    echo
    # Loop through each category
    for category in "${categories[@]}"; do
        # Initialize an empty array to store the group names that have been printed
        declare -A printed_groups

        # Loop through each file in the category
        for file in "$category"/*.sh; do

            # Extract functions from the file
            mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")

            # Loop through each function in the file
            for function in "${functions_in_file[@]}"; do
                key="${category##*/}:${file##*/}:${function}"
                group_name=${functions["$key,group_name"]}

                # If the group name has not been printed yet, print it and add it to the array
                declare -A printed_groups
                if [[ -z ${printed_groups["$group_name"]} ]]; then
                    echo "        $group_name,    [action]"
                    printed_groups["$group_name"]=1
                fi

                echo "               ${functions["$key,function_name"]} - ${functions["$key,description"]}"
				echo
            done
        done
		echo
    done
	echo
}

parse_action() {
    local group=$1
    local action=$2

    # Construct the full function name
    local function_name="${group}::${action}"

    # Check if the function exists
    if declare -f "$function_name" > /dev/null; then
        # Return the function name
        echo "$function_name"
    else
        echo "Error: Unknown action '$action' for group '$group'"
        return 1
    fi
}

see_tui() {
    local options=()
    local i=0
    declare -A categories_array
    for category in "${categories[@]}"; do
        local category_name="${category##*/}"
        local category_description=""
        local category_file="$category/readme.md"

        if [[ -f "$category_file" ]]; then
            category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
        fi

        categories_array["$i"]="$category_name"
        description_array["$i"]="$category_description"
        options+=("$i" "${categories_array[$i]} - ${description_array[$i]}")
        ((++i))
    done

    local choice
    
    choice=$($dialogue --menu "Select a category:" 0 0 9 "${options[@]}" 3>&1 1>&2 2>&3)
    
   
    if [[ -n $choice ]]; then
        see_sub_tui "${categories_array[$choice]}"
    fi
}

see_sub_tui() {
    local category="$1"
    local options=()
    local i=0
    declare -A functions_array
    for file in "$libpath/$filename/$category"/*.sh; do
        mapfile -t functions_in_file < <(grep -oP '(?<=function\s)\w+::\w+' "$file")
        for function in "${functions_in_file[@]}"; do
            key="${category##*/}:${file##*/}:${function}"
            functions_array["$i"]="$function"
            options+=("$i" "${functions["$key,function_name"]} - ${functions["$key,description"]}")
            ((++i))
        done
    done

    local choice
    
    choice=$($dialogue --menu "Select a function:" 0 0 9 "${options[@]}" 3>&1 1>&2 2>&3)
    
   
    if [[ -n $choice ]]; then
        see_action "${functions_array[$choice]}"
    fi

}

see_action() {
    local function_name="$1"
    local group_name=$(echo "$function_name" | sed 's/::.*//')
    local action_name=$(echo "$function_name" | sed 's/.*:://')
    local options="${functions["$group_name:$action_name,options"]}"

    local choice
    
    choice=$($dialogue --menu "Select an option:" 0 0 9 "1" "Run $action_name" "2" "Show help" 3>&1 1>&2 2>&3)
    
   
    if [[ -n $choice ]]; then
        if ((choice == 1)); then
            # Call the function using variable indirection
            ${function_name}
        elif ((choice == 2)); then
            see_help 
            
        fi
    fi
}

see_read() {
    echo
    echo "Please select an action:"
    echo
    # Initialize an empty array to store the function keys
    declare -a function_keys

    # Loop through each key in the functions array
    local i=1
    local current_category=""
    for key in "${!functions[@]}"; do
        if [[ $key == *",function_name" ]]; then
            # Add the key to the function_keys array
            function_keys[i]="${key%,function_name}"

            # Check if the category has changed and display it if so
            local category="${functions["${function_keys[i]},category"]}"
            if [[ "$category" != "$current_category" ]]; then
                echo "Category: $category"
                current_category="$category"
            fi

            # Display the function and its description as an option in the menu
            echo "  $i. ${functions["${function_keys[i]},group_name"]} ${functions[$key]}  - ${functions["${function_keys[i]},description"]}" #" < for my editor
            ((i++))
        fi
    done

    echo
    echo "$i. Show help"
    ((i++))
    echo "$i. Exit"

    read -p "Enter your choice: " choice

    if ((choice == i-1)); then
        see_help
        see_list
    elif ((choice == i)); then
        exit 0
    elif ((choice >= 1 && choice <= ${#function_keys[@]})); then
        # Call the selected function using variable indirection
        eval "${functions["${function_keys[choice]},group_name"]}::${functions["${function_keys[choice]},function_name"]}" #" < for my editor
    else
        echo "Invalid choice"
    fi
}

see_help(){
cat << EOF 
Usage: ${filename%.*} [flag] [option] [action]
  flags:
    -h,   Print this help.
    -t,   Show a Text-Base user interface.
    -d,   Show a debug information.
    -m,   Generate a readme.md. # README.md
    -j,   show a json ouput. # share/armbian-configng/configng.html
    -w,   Show a web ouput. # share/armbian-configng/commands.json
    -r,   [option]  [action]  To run a feature.
EOF
}

if [ "$1" == "-r" ]; then
    shift  # Shifts the arguments to the left, excluding the first argument ("-r")
    group_name="$1"  # Takes the first argument as the group name
    shift 1  # Shifts the arguments again to exclude the group name

    function_name=$(parse_action "$group_name" "$1")
    if [ $? -eq 0 ]; then
        # Call the function using variable indirection
        ${function_name}
    fi

elif [ "$1" == "-h" ]; then
	see_help
	see_list
elif [ "$1" == "-d" ] || [ $debug == "1" ] ; then
	see_debug
	exit
elif [ "$1" == "-t" ]  ; then
	see_tui
	exit
elif [ "$1" == "-j" ]  ; then
    see_json > ../share/armbian-configng/commands.json 
    chmod 755 ../share/armbian-configng/commands.json
	exit
elif [ "$1" == "-m" ]  ; then
        # Navigate to the root directory of the repository
    cd "$(dirname "$0")/../"
    see_markdown > ./readme.md
    chmod 755 ./readme.md
    cat ./readme.md
	exit
elif [ "$1" == "-w" ] ; then
    cd "$(dirname "$0")/../"
    see_html > ./index.html ;
    chmod 755 ./index.html ;
    #cat  "./index.html";

    see_html5 > "/home/gamma/configng/share/armbian-configng/$filename.html" ;
    chmod 755 ./index5.html ;
    #cat  "./index5.html";
    exit
else    
 	see_tui ;
	exit ;
fi
