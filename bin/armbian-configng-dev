#!/bin/bash

# This script provides a command-line interface for managing Armbian configuration.
# It loads libraries of functions from the lib directory and displays them in a menu.
# The user can select a function to run, or use a text-based user interface (TUI) to navigate the menus.
# The script also provides a help option and a debug option for developers.
# The script requires sudo privileges to run some functions.
# The script uses whiptail or dialog for the TUI, depending on which is available.

# TODO: Add more detailed documentation for each function and option in the script.

#Distrabution Compatibility check
[[ -f /usr/bin/armbian-config ]] && distro_congfig="armbian" ;
#Enable Dynamic directory root use home ~/ , /bin , /usr/sbin etc.. 
bin="$(dirname "${BASH_SOURCE[0]}")"
directory="$(cd "$bin/../" && pwd )"
filename="$(basename "${BASH_SOURCE[0]}")" ;
filename="${filename%.*}"
libpath=$(cd $directory/lib/$filename/ && pwd ) 
sharepath=$(cd $directory/share/${filename%-dev}/ && pwd )

# Check if the script is being run as root
# If not, check if the script is being run in development mode
# development mode bypassas root check many funtions will not work
dev="1"

if [[ "$(id -u)" != "0" ]] && [[ "$dev" != "1" ]]; then
    echo -e "E: This tool requires root privileges. Try: \"sudo $filename\" " >&2 && exit 1 ;
    [ -f /usr/lib/$filename ] && libpath=/user/lib/$filename
elif [[  "$(id -u)" != "0" ]] && [[ "$dev" == "1" ]]; then
    libpath=$(cd $directory/lib/$filename/ && pwd )
    { 
        echo "W: Running in UX development mode" 
        echo "W: Admin functions will not work" 
        sleep 2
    } | armbian-interface -o ;
elif [[  "$(id -u)" == "0" ]] && [[ "$dev" == "1" ]]; then
    libpath=$(cd $directory/lib/$filename/ && pwd )
    { 
        echo "W; Running in UX development mode" 
        echo "W: documents generated will requier root privileges to remove" 
        sleep 2
    } | armbian-interface -o ;
fi

declare -A dialogue

# Check if whiptail or dialog is installed and set the variable 'dialogue' accordingly.
# If neither is found, print "TUI not found" and return.
# todo add a fallback TUI and gui
if command -v whiptail &> /dev/null; then
    dialogue="whiptail"
elif command -v dialog &> /dev/null; then
    dialogue="dialog"
else
    echo "TUI not found
	Warning: Using fallback TUI"
    sleep 1
    clear && generate_read

fi
source "$libpath"/functions.sh
source "$libpath"/documents.sh
for file in "$libpath"/*/*.sh; do
    source "$file"
done

#mapfile -t categories < <(ls -d "$libpath"/* )
mapfile -t categories < <(find "$libpath"/* -type d)
declare -A functions

for category in "${categories[@]}"; do
    category_name="${category##*/}"

    category_file="$category/readme.md"
    if [[ -f "$category_file" ]]; then
        category_description=$(grep -oP "(?<=# @description ).*" "$category_file")
    fi

    for file in "$category"/*.sh; do
        description=""
        while IFS= read -r line; do
            if [[ $line =~ ^#\ @description\ (.*)$ ]]; then
                description="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^function\ (.*::.*)\(\)\{$ ]]; then
                function_name="${BASH_REMATCH[1]}"
                key="$category_name:${file##*/}:${function_name}"
                functions["$key,function_name"]=$(echo "$function_name" | sed 's/.*:://')
                functions["$key,group_name"]=$(echo "$function_name" | sed 's/::.*//')
                functions["$key,description"]=$description
            elif [[ $line =~ ^#\ @options\ (.*)$ ]]; then
                functions["$key,options"]="${BASH_REMATCH[1]}"
            fi
        done < "$file"
        functions["$key,category"]=$category_name
        functions["$key,category_description"]=$category_description
    done
done


# Check arguments for short flag options
# Check -r option first
if [[ "$1" == *"--"* ]]; then

    if [ "$1" == "--run" ]; then
        shift  # Shifts the arguments to the left, excluding the first argument ("-r")
        group_name="$1"  # Takes the first argument as the group name
        shift 1  # Shifts the arguments again to exclude the group name

        function_name=$(parse_action "$group_name" "$1")
        if [ $? -eq 0 ]; then
            # Call the function using variable indirection
            ${function_name}
        fi
    elif [ "$1" == "--help" ]; then
    generate_list
    exit
    fi
fi


# Generate a help message
if [ "$1" == "-h" ]; then
    generate_help
    exit 0 ;
# Generate a text-based user interface
elif [ "$1" == "-t" ]  ; then
    generate_read ; exit 0 ;    
# Generate all doc files
elif [ "$1" == "-d" ] ; then
    generate_doc ; exit 0 ;
elif [ "$1" == "-j" ] ; then
    generate_json ; exit 0 ;

fi


[[ -z "$1" ]] && generate_tui  ; exit 0 ;
