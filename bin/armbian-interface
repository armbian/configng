#!/bin/bash

#
# Copyright (c) 2023 Joseph C Turner
# All rights reserved.
#
# This script.
# demonstrates the compatibility of multiple interfaces for displaying menus or messages.
# It uses an array to set the options for all three menus (bash, whiptail, and dialog).
# The script checks if whiptail or dialog are available on the system and uses them to display the menu in a more user-friendly way.
# If neither of these programs is available, it falls back to using bash.
# while both are installed falls back to whiptail to display the menu.
# The user can override the default program by passing an argument when running the script:
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

## DIRECTORY variable to the absolute path of the script's directory
# directory="$(dirname "$(readlink -f "$0")")"
filename=$(basename "${BASH_SOURCE[0]}")

## DIALOG variable to the absolute path of the script's directory
DIALOG="bash"
[[ -x "$(command -v dialog)" ]] && DIALOG="dialog"
[[ -x "$(command -v whiptail)" ]] && DIALOG="whiptail"


show_message_00(){

    # Read the input from the pipe continuously until there is no more input
    input=""
    while read -r line; do
        input+="$line\n"
    done

    # Display the "OK" message box with the input data
    [[ $DIALOG != "bash" ]] && $DIALOG --title "Message Box" --msgbox "$input" 0 0
    [[ $DIALOG == "bash" ]] && echo -e "$input"
    [[ $DIALOG == "bash" ]] && read -p -r "Press [Enter] to continue..." ; echo "" ; exit 1

    }

show_message(){

    # Read the input from the pipe continuously until there is no more input
    input=""
    first_line_read=false
    while read -r line; do
        if $first_line_read; then
            input+="$line\n"
        else
            first_line_read=true
        fi
    done

    # Display the "OK" message box with the input data
    [[ $DIALOG != "bash" ]] && $DIALOG --title "Message Box" --msgbox "$input" 0 0
    [[ $DIALOG == "bash" ]] && echo -e "$input"
    [[ $DIALOG == "bash" ]] && read -p -r "Press [Enter] to continue..." ; echo "" ; exit 1

}

show_popup(){


    input=""
    while read -r line; do
        input+="$line\n"
    done
    
    [[ $DIALOG != "bash" ]] && $DIALOG --title "Popup Box" --infobox "$input" 0 0
    [[ $DIALOG == "bash" ]] && echo -e "$input"

    }

show_menu(){


    # Get the input and convert it into an array of options
    inpu_raw=$(cat)
    # Remove the lines befor -h 
	input=$(echo "$inpu_raw" | sed 's/-\([a-zA-Z]\)/\1/' | grep '^  [a-zA-Z] ' | grep -v '\[')
    options=()
    while read -r line; do
        package=$(echo "$line" | awk '{print $1}')
        description=$(echo "$line" | awk '{$1=""; print $0}' | sed 's/^ *//')
        options+=("$package" "$description")
    done <<< "$input"

    # Display the menu and get the user's choice
    [[ $DIALOG != "bash" ]] && choice=$($DIALOG --title "Menu" --menu "Choose an option:" 0 0 9 "${options[@]}" 3>&1 1>&2 2>&3)

	# Check if the user made a choice
	if [ $? -eq 0 ]; then
	    echo "$choice"
	else
	    echo "You cancelled."
	fi
	}

show_json_menu_repeatong() {
    # Extract all unique categories
    categories=$(jq -r '.[] | .Category' /home/joey/.local/share/armbian-configng/armbian-configng.json | sort -u)

    # Convert the categories into an array of options
    options=()
    while IFS= read -r category; do
        description=$(jq -r --arg category "$category" '.[] | select(.Category == $category) | .["Category Description"]' /home/joey/.local/share/armbian-configng/armbian-configng.json | head -1)
        options+=("$category" "$description")
    done <<< "$categories"

    # Display the category menu and get the user's choice
    category=$(whiptail --title "Category Menu" --menu "Choose a category:" 20 60 10 "${options[@]}" 3>&1 1>&2 2>&3)

    # Check if the user made a choice
    if [ $? -eq 0 ]; then
        # Parse the JSON file again to get the groups for the chosen category
        groups=$(jq -r --arg category "$category" '.[] | select(.Category == $category) | "\(.Group),\(.["Group Description"])"' /home/joey/.local/share/armbian-configng/armbian-configng.json)

        # Convert the groups into an array of options
        options=()
        while IFS= read -r line; do
            group=$(echo "$line" | cut -d',' -f1)
            description=$(echo "$line" | cut -d',' -f2)
            options+=("$group" "$description")
        done <<< "$groups"

        # Display the group menu and get the user's choice
        group=$(whiptail --title "Group Menu" --menu "Choose a group:" 20 60 10 "${options[@]}" 3>&1 1>&2 2>&3)

        # Check if the user made a choice
        if [ $? -eq 0 ]; then
            echo "You chose: $group=$function"
        else
            echo "You cancelled."
        fi
    else
        echo "You cancelled."
    fi
}

show_csv_menu() {
    # Parse the CSV file into a format that whiptail can use
    categories=$(awk -F, '{print $1 "," $2}' /home/joey/.local/share/armbian-configng/armbian-configng.csv)

    # Convert the categories into an array of options
    options=()
    while IFS= read -r line; do
        category=$(echo "$line" | cut -d',' -f1)
        description=$(echo "$line" | cut -d',' -f2)
        options+=("$category" "$description")
    done <<< "$categories"

    # Display the category menu and get the user's choice
    category=$($DIALOG --title "Category Menu" --menu "Choose a category:" 20 60 10 "${options[@]}" 3>&1 1>&2 2>&3)

    # Check if the user made a choice
    if [ $? -eq 0 ]; then
        # Parse the CSV file again to get the groups and functions for the chosen category
        groups_and_functions=$(awk -F, -v category="$category" '$1 == category {print $3 "," $4 "," $5}' /home/joey/.local/share/armbian-configng/armbian-configng.csv)

        # Convert the groups and functions into an array of options
        options=()
        while IFS= read -r line; do
            group=$(echo "$line" | cut -d',' -f1)
            function=$(echo "$line" | cut -d',' -f2)
            description=$(echo "$line" | cut -d',' -f3)
            options+=("$group" "$description")
        done <<< "$groups_and_functions"

        # Display the group menu and get the user's choice
        group=$(whiptail --title "Group Menu" --menu "Choose a group:" 20 60 10 "${options[@]}" 3>&1 1>&2 2>&3)

        # Check if the user made a choice
        if [ $? -eq 0 ]; then
            # Find the function for the chosen group
            function=$(echo "$groups_and_functions" | grep "^$group," | cut -d',' -f2)

            # Run the command with the chosen group and function as a key-value pair
            sudo "/home/joey/.local/bin/armbian-configng" "$group=$function"
        else
            echo "You cancelled."
        fi
    else
        echo "You cancelled."
    fi
}

show_json_menu() {
    # Parse the JSON file into a format that whiptail can use
    categories=$(jq -r '.[] | "\(.Category),\(.["Category Description"])"' /home/joey/.local/share/armbian-configng/armbian-configng.json)

    # Convert the categories into an array of options
    options=()
    while IFS= read -r line; do
        category=$(echo "$line" | cut -d',' -f1)
        description=$(echo "$line" | cut -d',' -f2)
        options+=("$category" "$description")
    done <<< "$categories"

    # Display the category menu and get the user's choice
    category=$($DIALOG --title "Category Menu" --menu "Choose a category:" 20 60 10 "${options[@]}" 3>&1 1>&2 2>&3)

    # Check if the user made a choice
    if [ $? -eq 0 ]; then
        # Parse the JSON file again to get the groups and functions for the chosen category
        groups_and_functions=$(jq -r --arg category "$category" '.[] | select(.Category == $category) | "\(.Group),\(.Function),\(.["Group Description"])"' /home/joey/.local/share/armbian-configng/armbian-configng.json)

        # Convert the groups and functions into an array of options
        options=()
        while IFS= read -r line; do
            group=$(echo "$line" | cut -d',' -f1)
            function=$(echo "$line" | cut -d',' -f2)
            description=$(echo "$line" | cut -d',' -f3)
            options+=("$group" "$description")
        done <<< "$groups_and_functions"

        # Display the group menu and get the user's choice
        group=$($DIALOG --title "Group Menu" --menu "Choose a group:" 20 60 10 "${options[@]}" 3>&1 1>&2 2>&3)

        # Check if the user made a choice
        if [ $? -eq 0 ]; then
            # Find the function for the chosen group
            function=$(echo "$groups_and_functions" | grep "^$group," | cut -d',' -f2)

            # Run the command with the chosen group and function as a key-value pair
            sudo "/home/joey/.local/bin/armbian-configng" "$group=$function"
        else
            echo "You cancelled."
        fi
    else
        echo "You cancelled."
    fi
}

show_help() {
        cat << EOF

Usage: [standard output] | ${0##*/} [option]

        -h, --help       Show this help message
        -m, --menu       Show the menu
        -o, --ok         Show the message. Accepts piped input (standard output from another command).
        -p, --popup      Show the popup
            --json       Show the JSON menu
            --csv        Show the CSV menu

        If no option is provided, the JSON menu will be shown.

    Environment Variables:
         dialog boxes, \$DIALOG currently set to: $DIALOG

    Example:
        echo "hello" | ${0##*/} -o
        echo "hello" | ${0##*/} --menu

    This will pipe the output of 'echo "hello"' into the script, which will then display 'OK: hello' if the -o option is used.

EOF
}

case "$1" in
    "-h" | "--help") show_help ;;
    "-m" | "--menu") show_menu ;;
    "-o" | "--message") show_message ;;
    "-p" | "--popup") show_popup ;;
           "--json") show_json_menu ;;
           "--csv") show_csv_menu ;;

    "") show_json_menu ;;
    *) echo "Invalid option: $1" ; show_help ;;
esac

